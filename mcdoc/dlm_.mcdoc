dispatch minecraft:storage["dlm:"] to struct{
    ticket?: NewRequest,
    n_t?: NormalizedRequest,
    proc?: struct{
        i?: int,
    },
    data?: [DimensionData],
    This_Dimension?: DimensionData,
    This_Chunk?: ChunkData,
    validations?: [Validation],
    This_Validation?: Validation,
    cmd?: struct{
        this?: Command,
        "any"?: (Command | [Command]),
        exe?: [Command]
    },
    pos?: Position,
    result_pos?: NormalizedPosition,
    live_tickets?: [LiveTicket],
    timed_tickets?: [LiveTicket],
    tt?: [LiveTicket],
    this_ticket?: LiveTicket,
    vld?: struct{
        life_types?: [LifeTypes] @ 3,
        i?: int,
        fload?: struct{...NormalizedPosition, dx?: int, dz?: int},
        cc?: struct{cx?: int, cz?: int}
    },
    gc?: [ChunkData],
    namespace?: string,
    "string"?: string,
    char?: string,
}

struct Validation{
    from_ticket?: string,
    temp?: boolean,
    on_pass?: [Command],
    tests?: [Command]
}

struct DimensionData {
    dimension?: Dimension,
    Chunks?: [ChunkData]
}

struct ChunkData{
    cx?: int,
    cz?: int,
    tickets?: [TicketFlag],
    alive?: boolean
}

struct LiveTicket{
    id?: string,
    life?: Life,
    until?: int
}

struct TicketFlag{
    id?: string,
    valid?: boolean,
}

struct NewRequest{
    /// Unique id for the request
    id?: string,
    /// Dimension of this force load applies to.
    /// If not specified, use the current command context if it is a vanilla dimension, otherwise an error will be thrown.
    dimension?: Dimension,
    /// Position of the chunk to load (Block coord)
    /// Can either be a struct containing x and z, or an array of length 2 `[x,z]` or 3 `[x,y,z]` (y will be ignored)
    pos?: Position,
    /// Optional `to` field to load multiple chunks in a rectangular area.
    to?: Position,
    /// Command(s) to execute when the chunk(s) are fully loaded
    on_load?: (Command | [Command]),
    /// Lifetime of this ticket
    life?: Life,
}

struct Life {
    /// Type of lifetime
    /// - `indefinite`: The ticket will never expire unless manually removed.
    /// - `temp`: The ticket will be auto-removed once the `on_load` command(s) have been executed.
    /// - `wait`: The ticket will be auto-removed after `time` ticks.
    type?: LifeTypes,
    /// for `type:wait` only. Spcecifies the number of ticks to wait before auto-removal.
    time?: CoordAllow
}

struct NormalizedRequest{
    id?: string,
    life?: Life,
    dimension?: Dimension,
    pos?: NormalizedPosition,
    to?: NormalizedPosition,
    on_load?: [Command],
}

enum(string) LifeTypes{
    indefinite = "indefinite",
    temp = "temp",
    wait = "wait"
}

type Command = #[command] string
type Position = ([CoordAllow] @ 1.. | byte[] @ 1..| int[] @ 1.. | long[] @ 1.. | struct{x?: CoordAllow, z?: CoordAllow})
type NormalizedPosition = struct{x?: int, z?: int, dimension?: Dimension}
type CoordAllow = (int|float|double|long|short|byte)
type Dimension = #[id="dimension"] string